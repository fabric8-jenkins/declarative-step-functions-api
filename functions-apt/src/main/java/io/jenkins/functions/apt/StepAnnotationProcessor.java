/**
 * Copyright (C) Original Authors 2017
 * <p>
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * <p>
 * http://www.apache.org/licenses/LICENSE-2.0
 * <p>
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.jenkins.functions.apt;


import io.jenkins.functions.Argument;
import io.jenkins.functions.Step;

import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.ElementFilter;
import java.beans.Introspector;
import java.io.IOException;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

/**
 * Processes all {@link Step} functions and generates the metadata for them
 */
@SupportedAnnotationTypes({"*"})
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class StepAnnotationProcessor extends AbstractAnnotationProcessor {

    public boolean process(Set<? extends TypeElement> annotations, final RoundEnvironment roundEnv) {
        if (roundEnv.processingOver()) {
            return true;
        }
        Set<? extends Element> elements = roundEnv.getElementsAnnotatedWith(Step.class);
        if (!elements.isEmpty()) {
            Properties properties = new Properties();
            for (Element element : elements) {
                if (element instanceof TypeElement) {
                    processStepClass(roundEnv, (TypeElement) element, properties);
                }
            }

            if (!properties.isEmpty()) {
                StringWriter writer = new StringWriter();
                try {
                    properties.store(writer, "Generated by functions-apt");
                    String text = writer.toString();

                    writeFile("io.jenkins.functions", "steps.properties", text);
                } catch (IOException e) {
                    log(e);
                }
            }
        }
        return true;
    }

    protected void processStepClass(final RoundEnvironment roundEnv, final TypeElement element, Properties properties) {
        final Step property = element.getAnnotation(Step.class);
        if (property != null) {
            String name = property.name();
            if (Strings.isNullOrEmpty(name)) {
                name = Introspector.decapitalize(element.getSimpleName().toString());
            }

            // TODO if is Callable or Function
            String javaTypeName = javaTypeName(element);
            properties.put(name, javaTypeName);

            // TODO write the step file!

            writeStepFile(element, name);

            Map<String, ExecutableElement> methods = findAllStepMethods(element);
            Set<Map.Entry<String, ExecutableElement>> entries = methods.entrySet();
            for (Map.Entry<String, ExecutableElement> entry : entries) {
                String methodName = entry.getKey();
                ExecutableElement methodElement = entry.getValue();
                writeStepFile(methodElement, methodName);
            }
        }
    }

    private void writeStepFile(Element element, String name) {
        StringWriter writer = new StringWriter();
        writer.append("step {\n" +
                "  metadata {\n" +
                "    name '" + name + "'\n" +
                "  }\n" +
                "  args {\n");

        if (element instanceof TypeElement) {
            TypeElement typeElement = (TypeElement) element;
            List<VariableElement> fields = findAllFields(typeElement);
            for (VariableElement fieldElement : fields) {
                Argument argument = fieldElement.getAnnotation(Argument.class);
                if (argument != null) {
                    String argName = argument.name();
                    String description = argument.description();
                    if (Strings.isNullOrEmpty(argName)) {
                        argName = fieldElement.getSimpleName().toString();
                    }

                    appendArgument(writer, argName, description, javaTypeName(fieldElement));
                }
            }
        } else if (element instanceof ExecutableElement) {
            ExecutableElement executableElement = (ExecutableElement) element;
            List<? extends VariableElement> parameters = executableElement.getParameters();
            if (parameters != null) {
                for (VariableElement parameter : parameters) {
                    String argName = null;
                    String description = null;
                    Argument argument = parameter.getAnnotation(Argument.class);
                    if (argument != null) {
                        argName = argument.name();
                        description = argument.description();
                    }
                    if (Strings.isNullOrEmpty(argName)) {
                        argName = parameter.getSimpleName().toString();
                    }
                    appendArgument(writer, argName, description, javaTypeName(parameter));
                }
            }
        }

        writer.append("  }\n" +
                "  steps {\n" +
                "    javaStepFunction  '" + name + " ${args}'\n" +
                "  }\n" +
                "}\n");

        String stepMarkup = writer.toString();
        writeFile("io.jenkins.functions", name + ".step", stepMarkup);
    }

    private void appendArgument(StringWriter writer, String argName, String description, String argTypeName) {
        if (Strings.notEmpty(argName)) {
            writer.append("    arg {\n" +
                    "      name '" + argName + "'\n");

            if (Strings.notEmpty(description)) {
                writer.append("      description '" + description + "'\n");
            }
            if (Strings.notEmpty(argTypeName)) {
                writer.append("      className '" + argTypeName + "'\n");
            }
            writer.append("    }\n");
        }
    }

    protected List<VariableElement> findAllFields(TypeElement element) {
        List<VariableElement> allFieldElements = new ArrayList<>();
        TypeElement e = element;
        while (true) {
            List<VariableElement> fieldElements = ElementFilter.fieldsIn(e.getEnclosedElements());
            allFieldElements.addAll(fieldElements);

            TypeMirror superclass = e.getSuperclass();
            if (superclass instanceof DeclaredType) {
                DeclaredType declaredType = (DeclaredType) superclass;
                Element typeElement = declaredType.asElement();
                String superclassName = javaTypeName(typeElement);
                if (Strings.isNullOrEmpty(superclassName) || superclassName.equals("java.lang.Object")) {
                    break;
                }
                if (typeElement instanceof TypeElement) {
                    e = (TypeElement) typeElement;
                } else {
                    break;
                }
            } else {
                break;
            }
        }
        return allFieldElements;
    }

    protected Map<String, ExecutableElement> findAllStepMethods(TypeElement element) {
        Map<String, ExecutableElement> allMethodElements = new HashMap<>();
        TypeElement e = element;
        while (true) {
            List<ExecutableElement> methodElements = ElementFilter.methodsIn(e.getEnclosedElements());
            for (ExecutableElement methodElement : methodElements) {
                Step step = methodElement.getAnnotation(Step.class);
                if (step != null) {
                    String name = step.name();
                    if (Strings.isNullOrEmpty(name)) {
                        name = methodElement.getSimpleName().toString();
                    }
                    if (!allMethodElements.containsKey(name)) {
                        allMethodElements.put(name, methodElement);
                    }
                }
            }

            TypeMirror superclass = e.getSuperclass();
            if (superclass instanceof DeclaredType) {
                DeclaredType declaredType = (DeclaredType) superclass;
                Element typeElement = declaredType.asElement();
                String superclassName = javaTypeName(typeElement);
                if (Strings.isNullOrEmpty(superclassName) || superclassName.equals("java.lang.Object")) {
                    break;
                }
                if (typeElement instanceof TypeElement) {
                    e = (TypeElement) typeElement;
                } else {
                    break;
                }
            } else {
                break;
            }
        }
        return allMethodElements;
    }
}
