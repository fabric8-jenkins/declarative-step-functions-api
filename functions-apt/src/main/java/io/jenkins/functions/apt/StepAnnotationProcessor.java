/**
 * Copyright (C) Original Authors 2017
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package io.jenkins.functions.apt;


import io.jenkins.functions.Argument;
import io.jenkins.functions.Step;

import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.type.DeclaredType;
import javax.lang.model.type.TypeMirror;
import javax.lang.model.util.ElementFilter;
import java.beans.Introspector;
import java.io.IOException;
import java.io.StringWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

/**
 * Processes all {@link Step} functions and generates the metadata for them
 */
@SupportedAnnotationTypes({"*"})
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class StepAnnotationProcessor extends AbstractAnnotationProcessor {

    public boolean process(Set<? extends TypeElement> annotations, final RoundEnvironment roundEnv) {
        if (roundEnv.processingOver()) {
            return true;
        }
        Set<? extends Element> elements = roundEnv.getElementsAnnotatedWith(Step.class);
        if (!elements.isEmpty()) {
            Properties properties = new Properties();
            for (Element element : elements) {
                if (element instanceof TypeElement) {
                    processStepClass(roundEnv, (TypeElement) element, properties);
                }
            }

            writePropertiesFile(properties, "io.jenkins.functions", "steps.properties");
        }
        return true;
    }

    protected void writePropertiesFile(Properties properties, String packageName, String fileName) {
        if (!properties.isEmpty()) {
            StringWriter writer = new StringWriter();
            try {
                properties.store(writer, "Generated by functions-apt");
                String text = writer.toString();

                writeFile(packageName, fileName, text);
            } catch (IOException e) {
                log(e);
            }
        }
    }

    protected void processStepClass(final RoundEnvironment roundEnv, final TypeElement element, Properties properties) {
        final Step classStep = element.getAnnotation(Step.class);
        if (classStep != null) {
            String name = classStep.name();
            if (Strings.isNullOrEmpty(name)) {
                name = Introspector.decapitalize(element.getSimpleName().toString());
            }
            String javaTypeName = javaTypeName(element);
            StepProperties classStepProperties = new StepProperties(name, javaTypeName, classStep);

            Map<String, ExecutableElement> methods = findAllStepMethods(element);
            Set<Map.Entry<String, ExecutableElement>> entries = methods.entrySet();
            for (Map.Entry<String, ExecutableElement> entry : entries) {
                String methodName = entry.getKey();
                ExecutableElement methodElement = entry.getValue();

                String functionName = name;
                boolean isApplyFunctionMethod = methodName.equals("apply") &&
                        hasInterface(element, "java.util.function.Function") && methodElement.getParameters().size() == 1;
                boolean isCallable = methodName.equals("call") && hasInterface(element, "java.util.concurrent.Callable");
                Element argumentsElement = methodElement;
                Step step = methodElement.getAnnotation(Step.class);
                if (step != null) {
                    String stepName = step.name();
                    if (Strings.isNullOrEmpty(stepName)) {
                        // lets default to the method name if we are not callable / function
                        if (isCallable || isApplyFunctionMethod) {
                            // lets not use the method name
                        } else {
                            stepName = methodName;
                        }
                    }
                    if (Strings.notEmpty(stepName)) {
                        functionName = stepName;
                    }
                }
                StepProperties stepProperties = new StepProperties(classStepProperties, functionName, step);

                if (isApplyFunctionMethod) {
                    Element variableElement = methodElement.getParameters().get(0);
                    TypeMirror typeMirror = variableElement.asType();
                    if (typeMirror instanceof DeclaredType) {
                        DeclaredType parameterDeclaredType = (DeclaredType) typeMirror;
                        argumentsElement = parameterDeclaredType.asElement();
                    }
                } else if (isCallable) {
                    argumentsElement = element;
                }
                writeStepFile(argumentsElement, functionName);

                stepProperties.store(properties);
            }
        }
    }

    private boolean hasInterface(TypeElement element, String intefaceName) {
        List<? extends TypeMirror> interfaces = element.getInterfaces();
        for (TypeMirror anInterface : interfaces) {
            if (anInterface instanceof DeclaredType) {
                DeclaredType declaredType = (DeclaredType) anInterface;
                String typeName = javaTypeName(declaredType.asElement());
                if (typeName.equals(intefaceName)) {
                    return true;
                }
                // try strip the generics off
                int idx = typeName.indexOf('<');
                if (idx > 0) {
                    typeName = typeName.substring(0, idx);
                    if (typeName.equals(intefaceName)) {
                        return true;
                    }
                }
                // TODO search superclasses?
            }
        }
        return false;
    }

    private void writeStepFile(Element element, String name) {
        StringWriter writer = new StringWriter();
        writer.append("step {\n" +
                "  metadata {\n" +
                "    name '" + name + "'\n" +
                "  }\n" +
                "  args {\n");

        Properties argumentProperties = new Properties();
        if (element instanceof TypeElement) {
            TypeElement typeElement = (TypeElement) element;
            List<VariableElement> fields = findAllFields(typeElement);
            for (VariableElement fieldElement : fields) {
                Argument argument = fieldElement.getAnnotation(Argument.class);
                if (argument != null) {
                    String argName = argument.name();
                    String description = argument.description();
                    if (Strings.isNullOrEmpty(argName)) {
                        argName = fieldElement.getSimpleName().toString();
                    }

                    appendArgument(writer, argName, description, javaTypeName(fieldElement), argumentProperties);
                }
            }
        } else if (element instanceof ExecutableElement) {
            ExecutableElement executableElement = (ExecutableElement) element;
            List<? extends VariableElement> parameters = executableElement.getParameters();
            if (parameters != null) {
                for (VariableElement parameter : parameters) {
                    String argName = null;
                    String description = null;
                    Argument argument = parameter.getAnnotation(Argument.class);
                    if (argument != null) {
                        argName = argument.name();
                        description = argument.description();
                    }
                    if (Strings.isNullOrEmpty(argName)) {
                        argName = parameter.getSimpleName().toString();
                    }
                    appendArgument(writer, argName, description, javaTypeName(parameter), argumentProperties);
                }
            }
        }
        writePropertiesFile(argumentProperties, "io.jenkins.functions", name + "-arguments.properties");

        writer.append("  }\n" +
                "  steps {\n" +
                "    javaStepFunction  '" + name + " ${args}'\n" +
                "  }\n" +
                "}\n");

        String stepMarkup = writer.toString();
        writeFile("io.jenkins.functions", name + ".step", stepMarkup);
    }

    private void appendArgument(StringWriter writer, String argName, String description, String argTypeName, Properties argumentProperties) {
        if (Strings.notEmpty(argName)) {
            writer.append("    arg {\n" +
                    "      name '" + argName + "'\n");

            if (Strings.notEmpty(description)) {
                writer.append("      description '" + description + "'\n");
                argumentProperties.put(argName + ".description", argTypeName);
            }
            if (Strings.notEmpty(argTypeName)) {
                writer.append("      className '" + argTypeName + "'\n");
                argumentProperties.put(argName + ".type", argTypeName);
            }
            writer.append("    }\n");
        }
    }

    protected List<VariableElement> findAllFields(TypeElement element) {
        List<VariableElement> allFieldElements = new ArrayList<>();
        TypeElement e = element;
        while (true) {
            List<VariableElement> fieldElements = ElementFilter.fieldsIn(e.getEnclosedElements());
            allFieldElements.addAll(fieldElements);

            TypeMirror superclass = e.getSuperclass();
            if (superclass instanceof DeclaredType) {
                DeclaredType declaredType = (DeclaredType) superclass;
                Element typeElement = declaredType.asElement();
                String superclassName = javaTypeName(typeElement);
                if (Strings.isNullOrEmpty(superclassName) || superclassName.equals("java.lang.Object")) {
                    break;
                }
                if (typeElement instanceof TypeElement) {
                    e = (TypeElement) typeElement;
                } else {
                    break;
                }
            } else {
                break;
            }
        }
        return allFieldElements;
    }

    protected Map<String, ExecutableElement> findAllStepMethods(TypeElement element) {
        Map<String, ExecutableElement> allMethodElements = new HashMap<>();
        TypeElement e = element;
        while (true) {
            List<ExecutableElement> methodElements = ElementFilter.methodsIn(e.getEnclosedElements());
            for (ExecutableElement methodElement : methodElements) {
                Step step = methodElement.getAnnotation(Step.class);
                if (step != null) {
                    String name = step.name();
                    if (Strings.isNullOrEmpty(name)) {
                        name = methodElement.getSimpleName().toString();
                    }
                    if (!allMethodElements.containsKey(name)) {
                        allMethodElements.put(name, methodElement);
                    }
                }
            }

            TypeMirror superclass = e.getSuperclass();
            if (superclass instanceof DeclaredType) {
                DeclaredType declaredType = (DeclaredType) superclass;
                Element typeElement = declaredType.asElement();
                String superclassName = javaTypeName(typeElement);
                if (Strings.isNullOrEmpty(superclassName) || superclassName.equals("java.lang.Object")) {
                    break;
                }
                if (typeElement instanceof TypeElement) {
                    e = (TypeElement) typeElement;
                } else {
                    break;
                }
            } else {
                break;
            }
        }
        return allMethodElements;
    }
}
